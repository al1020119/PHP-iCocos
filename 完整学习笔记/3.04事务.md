# 事务
### 一、事务的属性ACID
1. 原子性(atomicity):事务是一个原子操作单元，要么全部执行，要么全部都不执行
2. 一致性(consistent): 在事务开始和完成时，数据都必须保持一致性。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
3. 隔离性(lsolation): 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行。这意味着事务处理过程中的中间状态对外部是不可见的。
4. 持久性(Durable): 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。
###二、并发事务带来的问题
1.更新丢失

当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。

2.脏读

一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做"脏读"。

3.不可重复读

不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。

4.幻读

一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
###三、事务的隔离级别
1.读取未提交的内容(Read Uncommitted)
>(1)所有事务都可以看到其他未提交事务的执行结果
(2)该隔离级别引发的问题就是脏读：读取到了未提交的数据
```
#首先，修改隔离级别
set tx_isolation='READ-UNCOMMITTED';
select @@tx_isolation;
+------------------+
| @@tx_isolation   |
+------------------+
| READ-UNCOMMITTED |
+------------------+
#事务A：启动一个事务
start transaction;
select * from tx;
+------+------+
| id   | num  |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
+------+------+
#事务B：也启动一个事务(那么两个事务交叉了)
       在事务B中执行更新语句，且不提交
start transaction;
update tx set num=10 where id=1;
select * from tx;
+------+------+
| id   | num  |
+------+------+
|    1 |   10 |
|    2 |    2 |
|    3 |    3 |
+------+------+
#事务A：那么这时候事务A能看到这个更新了的数据吗?
select * from tx;
+------+------+
| id   | num  |
+------+------+
|    1 |   10 |   --->可以看到！说明我们读到了事务B还没有提交的数据
|    2 |    2 |
|    3 |    3 |
+------+------+
#事务B：事务B回滚,仍然未提交
rollback;
select * from tx;
+------+------+
| id   | num  |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
+------+------+
#事务A：在事务A里面看到的也是B没有提交的数据
select * from tx;
+------+------+
| id   | num  |
+------+------+
|    1 |    1 |      --->脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化我                             都可以看到！
|    2 |    2 |
|    3 |    3 |
+------+------+
 ```
 2.读取提交内容(Read Committed)
 >它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。
 但是它出现的问题是：不可重复读，不可重复读意味着我们在同一个事务中执行完全相同的select语句看到的可能是完全不一样的结果。导致这种情况的原因有：(1)有一个交叉的事务有新的commit，导致了数据的改变（2）一个数据库被多个实例操作时，同一个事务的其他实例在该实例处理其间有可能会有新的commit
 ``` 
 #首先修改隔离级别
 set tx_isolation='read-committed';
 select @@tx_isolation;
 +----------------+
 | @@tx_isolation |
 +----------------+
 | READ-COMMITTED |
 +----------------+
 #事务A：启动一个事务
 start transaction;
 select * from tx;
 +------+------+
 | id   | num  |
 +------+------+
 |    1 |    1 |
 |    2 |    2 |
 |    3 |    3 |
 +------+------+
 #事务B：也启动一个事务(那么两个事务交叉了)
        在这事务中更新数据，且未提交
 start transaction;
 update tx set num=10 where id=1;
 select * from tx;
 +------+------+
 | id   | num  |
 +------+------+
 |    1 |   10 |
 |    2 |    2 |
 |    3 |    3 |
 +------+------+
 #事务A：这个时候我们在事务A中能看到数据的变化吗?
 select * from tx; --------------->
 +------+------+                |
 | id   | num  |                |
 +------+------+                |
 |    1 |    1 |--->并不能看到！  |
 |    2 |    2 |                |
 |    3 |    3 |                |
 +------+------+                |——>相同的select语句，结果却不一样
                                |
 #事务B：如果提交了事务B呢?        |
 commit;                        |
                                |
 #事务A:                         |
 select * from tx; --------------->
 +------+------+
 | id   | num  |
 +------+------+
 |    1 |   10 |--->因为事务B已经提交了，所以在A中我们看到了数据变化
 |    2 |    2 |
 |    3 |    3 |
 +------+------+
 ```
 3.可重读（Repeatable Read）
 >(1)这是MySQL的默认事务隔离级别
  (2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行
  (3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行
  (4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题
  ``` 
  #首先，更改隔离级别
  set tx_isolation='repeatable-read';
  select @@tx_isolation;
  +-----------------+
  | @@tx_isolation  |
  +-----------------+
  | REPEATABLE-READ |
  +-----------------+
  
  #事务A：启动一个事务
  start transaction;
  select * from tx;
  +------+------+
  | id   | num  |
  +------+------+
  |    1 |    1 |
  |    2 |    2 |
  |    3 |    3 |
  +------+------+
  
  #事务B：开启一个新事务(那么这两个事务交叉了)
         在事务B中更新数据，并提交
  start transaction;
  update tx set num=10 where id=1;
  select * from tx;
  +------+------+
  | id   | num  |
  +------+------+
  |    1 |   10 |
  |    2 |    2 |
  |    3 |    3 |
  +------+------+
  commit;
  
  #事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？
  select * from tx;
  +------+------+
  | id   | num  |
  +------+------+
  |    1 |    1 | --->还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)
  |    2 |    2 |
  |    3 |    3 |
  +------+------+
  
  #事务A：只有当事务A也提交了，它才能够看到数据变化
  commit;
  select * from tx;
  +------+------+
  | id   | num  |
  +------+------+
  |    1 |   10 |
  |    2 |    2 |
  |    3 |    3 |
  +------+------+
  ```
 4.可串行化(Serializable)
 >(1)这是最高的隔离级别
  (2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。
  (3)在这个级别，可能导致大量的超时现象和锁竞争
  ``` 
  #首先修改隔离界别
  set tx_isolation='serializable';
  select @@tx_isolation;
  +----------------+
  | @@tx_isolation |
  +----------------+
  | SERIALIZABLE   |
  +----------------+
  
  #事务A：开启一个新事务
  start transaction;
  
  #事务B：在A没有commit之前，这个交叉事务是不能更改数据的
  start transaction;
  insert tx values('4','4');
  ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
  update tx set num=10 where id=1;
  ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
  ```
