# SQL查询优化

### 一、优化的入手点

- 查找分析查询慢的原因
> 1.记录慢查询日志（慢查询日志的使用以及分析见本章slow_query.md)  
2.show profile:  
set profiling = 1;开启，服务器上执行的所有语句会检测消耗的时间，存到临时表  
show profiles 查看语句执行消耗的时间  
show profile for query 临时表ID  查看某个查询的详细消耗  
3.分析单条语句使用explain（explain.md查看explain用法）

- 优化查询中的数据访问
>1.访问数据太多导致查询性能下降，尽量不要使用select *  
2.确定应用程序逻辑需要的数据量，使用limit返回一部分即可  
3.确定MySQL是否检索了索引，避免全表扫描  
4.重复查询相同的数据，可以缓存数据，下次直接读缓存  
5.是否存在扫描额外的记录（使用explain分析发现需要扫描大量的数据，却只返回少数行）：  
使用索引覆盖扫描，把所用到的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果  

- 优化长难语句
>一个复杂的查询和多个简单的查询相比较，mysql每秒可以查询上百万的数据，响应给客户端的速度就要慢得多，所以使用尽可能少的查询是好的，但是有时候把一个大查询分解为多个小的查询也是必要的。因为长时间的sql会产生临时表、锁表、占用数据连接等情况，影响其他的查询。  
解决方案：  
1.切分查询，将一条大的查询切分成多个小的查询，分批次执行  
2.分解关联查询， 将一个关联语句分解成多个sql来执行，减少锁的竞争，并且在应用层进行关联，以后更容易拆分数据库  


- 优化特定类型的查询语句
> 1.优化关联查询，确定on的子句有没有索引，避免全表扫描  
2.确保group by和order by中只有一个表中的列，这样才会使用到索引  
3.优化子查询，尽量使用关联查询来替代子查询(因为mysql对关联查询会有一些优化器，但是高性能mysql上说了，在mysql5.6以上版本或者MariaDB中，子查询和关联查询的效率是差不多的)  
4.优化limit分页，当limit偏移量大的时候，查询效率就会很低。此时我们可以记录上次查询的最大id，下次查询时直接根据该id来查询  
比如每页需要显示10条数据，到limit 10000,10的时候，其实是查出了10010条结果集，返回了10条。如果我们记住上一次查询的最大id，10000.我们可以使用 where id > 10000 limit 10，这样还是只在10条数据中返回，极大的提升了运行效率